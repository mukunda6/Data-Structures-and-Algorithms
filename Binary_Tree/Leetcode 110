// ============================================================
// Problem: Check if Binary Tree is Height Balanced
// Category: Binary Tree
//
// A binary tree is balanced if:
// For every node,
// |height(left) - height(right)| <= 1
//
// Approaches:
// 1ï¸âƒ£ Naive Method
//     - Compute height repeatedly
//     Time: O(n^2)
//
// 2ï¸âƒ£ Optimized Method
//     - Single traversal returning height
//     - Use -1 to indicate imbalance
//     Time: O(n)
//
// ============================================================

#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;

///////////////////////////////////////////////////////////////
// Binary Tree Node Definition
///////////////////////////////////////////////////////////////
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;

    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *l, TreeNode *r)
        : val(x), left(l), right(r) {}
};

class Solution {
public:

    ///////////////////////////////////////////////////////////
    // ðŸ”¹ METHOD 1 â€” Naive O(n^2)
    ///////////////////////////////////////////////////////////
    int getHt(TreeNode* node) {
        if(node == NULL) return 0;
        return max(getHt(node->left),
                   getHt(node->right)) + 1;
    }

    bool isBalancedNaive(TreeNode* root) {
        if(root == NULL) return true;

        int lh = getHt(root->left);
        int rh = getHt(root->right);

        return abs(lh - rh) <= 1 &&
               isBalancedNaive(root->left) &&
               isBalancedNaive(root->right);
    }

    ///////////////////////////////////////////////////////////
    // ðŸ”¹ METHOD 2 â€” Optimized O(n)
    ///////////////////////////////////////////////////////////
    int diff(TreeNode* root) {
        if(root == NULL) return 0;

        int l = diff(root->left);
        if(l == -1) return -1;

        int r = diff(root->right);
        if(r == -1) return -1;

        if(abs(l - r) > 1)
            return -1;

        return max(l, r) + 1;
    }

    bool isBalancedOptimized(TreeNode* root) {
        return diff(root) != -1;
    }
};

///////////////////////////////////////////////////////////////
// Main Test Driver
///////////////////////////////////////////////////////////////
int main() {

    /*
        Example Tree

                1
               / \
              2   3
             /
            4
           /
          5

        (NOT Balanced)
    */

    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->left->left = new TreeNode(5);

    Solution obj;

    cout << "Naive Method: ";
    cout << (obj.isBalancedNaive(root) ?
             "Balanced\n" : "Not Balanced\n");

    cout << "Optimized Method: ";
    cout << (obj.isBalancedOptimized(root) ?
             "Balanced\n" : "Not Balanced\n");

    return 0;
}

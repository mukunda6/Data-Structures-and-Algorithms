# ğŸ” Recursion â€“ Complete Guide with Types & Programs (C++)

This repository contains a **complete explanation of Recursion**
with **all recursion types, definitions, examples, and C++ programs**
combined into a **single well-documented file**.

Perfect for:
- DSA learning
- Interviews
- Revision before exams

---

## ğŸ”¹ What is Recursion?

Recursion is a technique where a function calls itself
to solve a problem by breaking it into smaller sub-problems.

Every recursive function must have:
- **Base Case** â†’ stops recursion
- **Recursive Case** â†’ function calls itself

---

## ğŸ“š Recursion Types Covered

1. Direct Recursion  
2. Indirect Recursion  
3. Tail Recursion  
4. Non-Tail (Head) Recursion  
5. Linear Recursion  
6. Binary Recursion  
7. Multiple (Tree) Recursion  
8. Nested Recursion  
9. Mutual Recursion  
10. Tree Recursion  

All concepts + programs are included in **one C++ file**.

---

## ğŸ“Š Recursion Types Summary

| Type | Calls | Example |
|-----|------|--------|
| Direct | 1 | Factorial |
| Indirect | â‰¥2 | A â†’ B â†’ A |
| Tail | 1 (last) | Optimized factorial |
| Non-Tail | 1 | Print numbers |
| Linear | 1 | Sum |
| Binary | 2 | Fibonacci |
| Multiple | >2 | Staircase |
| Nested | Inside call | McCarthy |
| Mutual | 2 functions | Odd-Even |
| Tree | Many | Backtracking |

---

## ğŸ¯ Interview Tips
- Always identify the base case
- Draw recursion tree
- Understand stack memory
- Analyze time complexity

---

## ğŸ§ª Complete C++ Program (All-in-One)

```cpp
/*
====================================================
 ğŸ” RECURSION â€“ COMPLETE GUIDE WITH PROGRAMS (C++)
====================================================
*/

#include <bits/stdc++.h>
using namespace std;

/* 1ï¸âƒ£ DIRECT RECURSION */
int factorial(int n) {
    if (n == 0) return 1;
    return n * factorial(n - 1);
}

/* 2ï¸âƒ£ INDIRECT RECURSION */
void B(int n);

void A(int n) {
    if (n > 0) {
        cout << n << " ";
        B(n - 1);
    }
}

void B(int n) {
    if (n > 0) {
        cout << n << " ";
        A(n - 1);
    }
}

/* 3ï¸âƒ£ TAIL RECURSION */
int factorialTail(int n, int result) {
    if (n == 0) return result;
    return factorialTail(n - 1, n * result);
}

/* 4ï¸âƒ£ NON-TAIL RECURSION */
void printNumbers(int n) {
    if (n == 0) return;
    printNumbers(n - 1);
    cout << n << " ";
}

/* 5ï¸âƒ£ LINEAR RECURSION */
int sum(int n) {
    if (n == 0) return 0;
    return n + sum(n - 1);
}

/* 6ï¸âƒ£ BINARY RECURSION */
int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

/* 7ï¸âƒ£ MULTIPLE RECURSION */
int ways(int n) {
    if (n <= 1) return 1;
    return ways(n - 1) + ways(n - 2) + ways(n - 3);
}

/* 8ï¸âƒ£ NESTED RECURSION */
int fun(int n) {
    if (n > 100)
        return n - 10;
    return fun(fun(n + 11));
}

/* 9ï¸âƒ£ MUTUAL RECURSION */
bool isOdd(int n);

bool isEven(int n) {
    if (n == 0) return true;
    return isOdd(n - 1);
}

bool isOdd(int n) {
    if (n == 0) return false;
    return isEven(n - 1);
}

/* ğŸ”Ÿ TREE RECURSION */
void tree(int x) {
    if (x > 0) {
        tree(x - 1);
        cout << x << " ";
        tree(x - 1);
    }
}

int main() {
    cout << "Direct Recursion (Factorial): " << factorial(5) << endl;

    cout << "Indirect Recursion: ";
    A(5);
    cout << endl;

    cout << "Tail Recursion: " << factorialTail(5, 1) << endl;

    cout << "Non-Tail Recursion: ";
    printNumbers(5);
    cout << endl;

    cout << "Linear Recursion (Sum): " << sum(5) << endl;
    cout << "Binary Recursion (Fibonacci): " << fibonacci(5) << endl;
    cout << "Multiple Recursion (Ways): " << ways(4) << endl;
    cout << "Nested Recursion: " << fun(95) << endl;
    cout << "Mutual Recursion (isEven): " << isEven(10) << endl;

    cout << "Tree Recursion: ";
    tree(3);
    cout << endl;

    return 0;
}
/*
====================================================
 ğŸ” RECURSION â€“ COMPLETE GUIDE WITH PROGRAMS (C++)
====================================================

Recursion is a technique where a function calls itself
to solve a problem by breaking it into smaller sub-problems.

Every recursive function must have:
1ï¸âƒ£ Base Case â€“ stops recursion
2ï¸âƒ£ Recursive Case â€“ function calls itself

====================================================
*/

#include <bits/stdc++.h>
using namespace std;

/*--------------------------------------------------
  1ï¸âƒ£ DIRECT RECURSION
  Function calls itself directly
--------------------------------------------------*/
int factorial(int n) {
    if (n == 0) return 1;
    return n * factorial(n - 1);
}

/*--------------------------------------------------
  2ï¸âƒ£ INDIRECT RECURSION
  Functions call each other
--------------------------------------------------*/
void B(int n);

void A(int n) {
    if (n > 0) {
        cout << n << " ";
        B(n - 1);
    }
}

void B(int n) {
    if (n > 0) {
        cout << n << " ";
        A(n - 1);
    }
}

/*--------------------------------------------------
  3ï¸âƒ£ TAIL RECURSION
  Recursive call is the last statement
--------------------------------------------------*/
int factorialTail(int n, int result) {
    if (n == 0) return result;
    return factorialTail(n - 1, n * result);
}

/*--------------------------------------------------
  4ï¸âƒ£ NON-TAIL (HEAD) RECURSION
  Work done after recursive call
--------------------------------------------------*/
void printNumbers(int n) {
    if (n == 0) return;
    printNumbers(n - 1);
    cout << n << " ";
}

/*--------------------------------------------------
  5ï¸âƒ£ LINEAR RECURSION
  One recursive call per function
--------------------------------------------------*/
int sum(int n) {
    if (n == 0) return 0;
    return n + sum(n - 1);
}

/*--------------------------------------------------
  6ï¸âƒ£ BINARY RECURSION
  Two recursive calls
--------------------------------------------------*/
int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

/*--------------------------------------------------
  7ï¸âƒ£ MULTIPLE (TREE) RECURSION
  More than two recursive calls
--------------------------------------------------*/
int ways(int n) {
    if (n <= 1) return 1;
    return ways(n - 1) + ways(n - 2) + ways(n - 3);
}

/*--------------------------------------------------
  8ï¸âƒ£ NESTED RECURSION
  Recursive call inside another call
--------------------------------------------------*/
int fun(int n) {
    if (n > 100)
        return n - 10;
    return fun(fun(n + 11));
}

/*--------------------------------------------------
  9ï¸âƒ£ MUTUAL RECURSION
  Two functions call each other
--------------------------------------------------*/
bool isOdd(int n);

bool isEven(int n) {
    if (n == 0) return true;
    return isOdd(n - 1);
}

bool isOdd(int n) {
    if (n == 0) return false;
    return isEven(n - 1);
}

/*--------------------------------------------------
 ğŸ”Ÿ TREE RECURSION
  Each call generates multiple child calls
--------------------------------------------------*/
void tree(int x) {
    if (x > 0) {
        tree(x - 1);
        cout << x << " ";
        tree(x - 1);
    }
}

/*--------------------------------------------------
  MAIN FUNCTION (DEMO)
--------------------------------------------------*/
int main() {

    cout << "Direct Recursion (Factorial): "
         << factorial(5) << endl;

    cout << "Indirect Recursion: ";
    A(5);
    cout << endl;

    cout << "Tail Recursion (Factorial): "
         << factorialTail(5, 1) << endl;

    cout << "Non-Tail Recursion: ";
    printNumbers(5);
    cout << endl;

    cout << "Linear Recursion (Sum): "
         << sum(5) << endl;

    cout << "Binary Recursion (Fibonacci): "
         << fibonacci(5) << endl;

    cout << "Multiple Recursion (Ways): "
         << ways(4) << endl;

    cout << "Nested Recursion: "
         << fun(95) << endl;

    cout << "Mutual Recursion (isEven): "
         << isEven(10) << endl;

    cout << "Tree Recursion: ";
    tree(3);
    cout << endl;

    return 0;
}

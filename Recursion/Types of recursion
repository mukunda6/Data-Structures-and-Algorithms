# üîÅ Recursion ‚Äì Complete Guide with Types & Programs (C++)

This repository contains a **complete explanation of Recursion**
with **all recursion types, definitions, examples, and C++ programs**
combined into a **single well-documented file**.

Perfect for:
- DSA learning
- Interviews
- Revision before exams

---

## üîπ What is Recursion?

Recursion is a technique where a function calls itself
to solve a problem by breaking it into smaller sub-problems.

Every recursive function must have:
- **Base Case** ‚Üí stops recursion
- **Recursive Case** ‚Üí function calls itself

---

## üìö Recursion Types Covered

1. Direct Recursion  
2. Indirect Recursion  
3. Tail Recursion  
4. Non-Tail (Head) Recursion  
5. Linear Recursion  
6. Binary Recursion  
7. Multiple (Tree) Recursion  
8. Nested Recursion  
9. Mutual Recursion  
10. Tree Recursion  

All concepts + programs are included in **one C++ file**.

---

## üìä Recursion Types Summary

| Type | Calls | Example |
|-----|------|--------|
| Direct | 1 | Factorial |
| Indirect | ‚â•2 | A ‚Üí B ‚Üí A |
| Tail | 1 (last) | Optimized factorial |
| Non-Tail | 1 | Print numbers |
| Linear | 1 | Sum |
| Binary | 2 | Fibonacci |
| Multiple | >2 | Staircase |
| Nested | Inside call | McCarthy |
| Mutual | 2 functions | Odd-Even |
| Tree | Many | Backtracking |

---

## üéØ Interview Tips
- Always identify the base case
- Draw recursion tree
- Understand stack memory
- Analyze time complexity

---

====================================================
 üîÅ RECURSION ‚Äì COMPLETE GUIDE WITH PROGRAMS (C++)
====================================================

Recursion is a technique where a function calls itself
to solve a problem by breaking it into smaller sub-problems.

Every recursive function must have:
1Ô∏è‚É£ Base Case ‚Äì stops recursion
2Ô∏è‚É£ Recursive Case ‚Äì function calls itself

====================================================
*/

#include <bits/stdc++.h>
using namespace std;

/*--------------------------------------------------
  1Ô∏è‚É£ DIRECT RECURSION
  Function calls itself directly
--------------------------------------------------*/
int factorial(int n) {
    if (n == 0) return 1;
    return n * factorial(n - 1);
}

/*--------------------------------------------------
  2Ô∏è‚É£ INDIRECT RECURSION
  Functions call each other
--------------------------------------------------*/
void B(int n);

void A(int n) {
    if (n > 0) {
        cout << n << " ";
        B(n - 1);
    }
}

void B(int n) {
    if (n > 0) {
        cout << n << " ";
        A(n - 1);
    }
}

/*--------------------------------------------------
  3Ô∏è‚É£ TAIL RECURSION
  Recursive call is the last statement
--------------------------------------------------*/
int factorialTail(int n, int result) {
    if (n == 0) return result;
    return factorialTail(n - 1, n * result);
}

/*--------------------------------------------------
  4Ô∏è‚É£ NON-TAIL (HEAD) RECURSION
  Work done after recursive call
--------------------------------------------------*/
void printNumbers(int n) {
    if (n == 0) return;
    printNumbers(n - 1);
    cout << n << " ";
}

/*--------------------------------------------------
  5Ô∏è‚É£ LINEAR RECURSION
  One recursive call per function
--------------------------------------------------*/
int sum(int n) {
    if (n == 0) return 0;
    return n + sum(n - 1);
}

/*--------------------------------------------------
  6Ô∏è‚É£ BINARY RECURSION
  Two recursive calls
--------------------------------------------------*/
int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

/*--------------------------------------------------
  7Ô∏è‚É£ MULTIPLE (TREE) RECURSION
  More than two recursive calls
--------------------------------------------------*/
int ways(int n) {
    if (n <= 1) return 1;
    return ways(n - 1) + ways(n - 2) + ways(n - 3);
}

/*--------------------------------------------------
  8Ô∏è‚É£ NESTED RECURSION
  Recursive call inside another call
--------------------------------------------------*/
int fun(int n) {
    if (n > 100)
        return n - 10;
    return fun(fun(n + 11));
}

/*--------------------------------------------------
  9Ô∏è‚É£ MUTUAL RECURSION
  Two functions call each other
--------------------------------------------------*/
bool isOdd(int n);

bool isEven(int n) {
    if (n == 0) return true;
    return isOdd(n - 1);
}

bool isOdd(int n) {
    if (n == 0) return false;
    return isEven(n - 1);
}

/*--------------------------------------------------
 üîü TREE RECURSION
  Each call generates multiple child calls
--------------------------------------------------*/
void tree(int x) {
    if (x > 0) {
        tree(x - 1);
        cout << x << " ";
        tree(x - 1);
    }
}

/*--------------------------------------------------
  MAIN FUNCTION (DEMO)
--------------------------------------------------*/
int main() {

    cout << "Direct Recursion (Factorial): "
         << factorial(5) << endl;

    cout << "Indirect Recursion: ";
    A(5);
    cout << endl;

    cout << "Tail Recursion (Factorial): "
         << factorialTail(5, 1) << endl;

    cout << "Non-Tail Recursion: ";
    printNumbers(5);
    cout << endl;

    cout << "Linear Recursion (Sum): "
         << sum(5) << endl;

    cout << "Binary Recursion (Fibonacci): "
         << fibonacci(5) << endl;

    cout << "Multiple Recursion (Ways): "
         << ways(4) << endl;

    cout << "Nested Recursion: "
         << fun(95) << endl;

    cout << "Mutual Recursion (isEven): "
         << isEven(10) << endl;

    cout << "Tree Recursion: ";
    tree(3);
    cout << endl;

    return 0;
}
